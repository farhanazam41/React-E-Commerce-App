{"ast":null,"code":"import Stripe from \"stripe\";\nimport uuidv4 from \"uuid/v4\";\nimport jwt from \"jsonwebtoken\";\nimport Cart from \"../../models/Cart\";\nimport Order from \"../../models/Order\";\nimport calculateCarTotal from \"../../utils/calculateCartTotal\";\nconst stripe = Stripe(process.env.STRIPE_SECRET_KEY);\nexport default (async (req, res) => {\n  const {\n    paymentData\n  } = req.body;\n\n  try {\n    // 1) Verify and get user id from token\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET); // 2) Find cart based on user id, populate it\n\n    const cart = await Cart.findOne({\n      user: userId\n    }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    }); // 3) Calculate cart totals again from cart products\n\n    const {\n      cartTotal,\n      stripeTotal\n    } = calculateCarTotal(cart.products); // 4) Get email from payment data, see if email linked with existing Stripe customer\n\n    const prevCustomer = await stripe.customers.list({\n      email: paymentData.email,\n      limit: 1\n    });\n    const isExistingCustomer = prevCustomer.data.length > 0; // 5) If not existing customer, create them based on their email\n\n    let newCustomer;\n\n    if (!isExistingCustomer) {\n      newCustomer = await stripe.customers.create({\n        email: paymentData.email,\n        source: paymentData.id\n      });\n    }\n\n    const customer = isExistingCustomer && prevCustomer.data[0].id || newCustomer.id; // 6) Create charge with total, send receipt email\n\n    const charge = await stripe.charges.create({\n      currency: \"usd\",\n      amount: stripeTotal,\n      receipt_email: paymentData.email,\n      customer,\n      description: `Checkout | ${paymentData.email} | ${paymentData.id}`\n    }, {\n      idempotency_key: uuidv4()\n    }); // 7) Add order data to database\n\n    await new Order({\n      user: userId,\n      email: paymentData.email,\n      total: cartTotal,\n      products: cart.products\n    }).save(); // 8) Clear products in cart\n\n    await Cart.findOneAndUpdate({\n      _id: cart._id\n    }, {\n      $set: {\n        products: []\n      }\n    }); // 9) Send back success (200) response\n\n    res.status(200).send(\"Checkout successful\");\n  } catch (error) {\n    console.error(error);\n    res.status(500).send(\"Error processing charge\");\n  }\n});","map":{"version":3,"sources":["C:\\Users\\farha\\Desktop\\reacttest\\pages\\api\\checkout.js"],"names":["Stripe","uuidv4","jwt","Cart","Order","calculateCarTotal","stripe","process","env","STRIPE_SECRET_KEY","req","res","paymentData","body","userId","verify","headers","authorization","JWT_SECRET","cart","findOne","user","populate","path","model","cartTotal","stripeTotal","products","prevCustomer","customers","list","email","limit","isExistingCustomer","data","length","newCustomer","create","source","id","customer","charge","charges","currency","amount","receipt_email","description","idempotency_key","total","save","findOneAndUpdate","_id","$set","status","send","error","console"],"mappings":"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","sourcesContent":["import Stripe from \"stripe\";\r\nimport uuidv4 from \"uuid/v4\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport Cart from \"../../models/Cart\";\r\nimport Order from \"../../models/Order\";\r\nimport calculateCarTotal from \"../../utils/calculateCartTotal\";\r\n\r\nconst stripe = Stripe(process.env.STRIPE_SECRET_KEY);\r\n\r\nexport default async (req, res) => {\r\n  const { paymentData } = req.body;\r\n\r\n  try {\r\n    // 1) Verify and get user id from token\r\n    const { userId } = jwt.verify(\r\n      req.headers.authorization,\r\n      process.env.JWT_SECRET\r\n    );\r\n    // 2) Find cart based on user id, populate it\r\n    const cart = await Cart.findOne({ user: userId }).populate({\r\n      path: \"products.product\",\r\n      model: \"Product\"\r\n    });\r\n    // 3) Calculate cart totals again from cart products\r\n    const { cartTotal, stripeTotal } = calculateCarTotal(cart.products);\r\n    // 4) Get email from payment data, see if email linked with existing Stripe customer\r\n    const prevCustomer = await stripe.customers.list({\r\n      email: paymentData.email,\r\n      limit: 1\r\n    });\r\n    const isExistingCustomer = prevCustomer.data.length > 0;\r\n    // 5) If not existing customer, create them based on their email\r\n    let newCustomer;\r\n    if (!isExistingCustomer) {\r\n      newCustomer = await stripe.customers.create({\r\n        email: paymentData.email,\r\n        source: paymentData.id\r\n      });\r\n    }\r\n    const customer =\r\n      (isExistingCustomer && prevCustomer.data[0].id) || newCustomer.id;\r\n    // 6) Create charge with total, send receipt email\r\n    const charge = await stripe.charges.create(\r\n      {\r\n        currency: \"usd\",\r\n        amount: stripeTotal,\r\n        receipt_email: paymentData.email,\r\n        customer,\r\n        description: `Checkout | ${paymentData.email} | ${paymentData.id}`\r\n      },\r\n      {\r\n        idempotency_key: uuidv4()\r\n      }\r\n    );\r\n    // 7) Add order data to database\r\n    await new Order({\r\n      user: userId,\r\n      email: paymentData.email,\r\n      total: cartTotal,\r\n      products: cart.products\r\n    }).save();\r\n    // 8) Clear products in cart\r\n    await Cart.findOneAndUpdate({ _id: cart._id }, { $set: { products: [] } });\r\n    // 9) Send back success (200) response\r\n    res.status(200).send(\"Checkout successful\");\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).send(\"Error processing charge\");\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}